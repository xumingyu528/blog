

## 异常



### 常见类别

* 中断（interrupt）：来自 I/O 设备的信号，异步，总是返回到下一条指令
* 陷阱（trap）：有意的异常，同步，总是返回到下一条指令
* 故障（fault）：潜在可恢复的错误，同步，可能返回到当前指令
* 终止（abort）：不可恢复的错误，同步，不会返回



中断来自网络适配器、磁盘控制器、定时器芯片等，通过向处理器芯片上的一个引脚发信号，将异常号放到系统总线上，来触发中断，异常号标示了引起中断的设备。  

陷阱是有意的异常，用户程序经常向内核请求服务，比如读取一个文件（read）、创建一个新的进程（fork）、加载一个新的程序（execve）、终止当前进程（exit）。处理器提供了一条特殊的“syscall n”指令，当用户想要请求服务 n 时，执行这条指令，执行 syscall 指令会导致一个到异常处理程序的陷阱，这个处理程序解析参数，并调用适当的内核程序。  

系统调用（syscall）看起来和函数调用一样。但普通的函数运行在用户模式，他们只能访问和调用函数相同的栈，系统调用运行在内核模式，内核模式允许系统调用执行特权指令，并访问定义在内核中的栈。  

故障由错误引起，它可能被故障处理程序修正。如果被修正则将控制返回到引起故障的指令，从而重新执行，否则处理程序返回到内核中的 abort 例程，abort 例程会终止该应用程序。 一个经典的故障是缺页异常，当指令引用一个虚拟地址，改地址对应的物理页面不在内存中，需要从磁盘中取出，就会发生故障。缺页处理程序从磁盘加载适当的页面后，重新返回给引起故障的指令，再次执行指令时，相应的物理页面已经存在内存中了。  

终止时不可恢复的致命错误造成的结果，通常是硬件错误，例如 DRAM、SRAM 位被损坏发生奇偶错误。  

x86_64 定义了256种不同的异常类型，0~31的号码对应的由Intel架构师定义的异常，32~255 对应的是操作系统定义的中断和陷阱。  

常见故障和终止：

* 除法错误
* 一般保护故障、段故障（Segmentation fault）
* 缺页
* 机器检查



C程序用 syscall 函数可以直接调用任何系统调用。标准 C 库提供了一组方便的包装函数。系统调用和相关联的包装函数都称为系统级函数。  

常见系统调用：

| 编号 | 名字 | 描述 |
| ---- | ---- | ---- |
| 0	    | read   |  读文件				      |
| 1 	| write  |   写文件                     |
| 2 	| open   |  打开文件                    |
| 3 	| close  |   关闭文件                   |
| 4 	| stat   |  获得文件信息                 |
| 9 	| mmap   |  将内存页映射到文件            |
| 12	| brk    | 重置堆顶                     |
| 32	| dup2   |  复制文件描述符                |
| 33	| pause  |   挂起进程直到信号到达          |
| 37	| alarm  |   调度告警信号的传送           |
| 39	| getpid |    获得进程 ID               |
| 57	| fork   |  创建进程                    |
| 59	| execve |    执行一个程序               |
| 60	| _exit  |   终止进程                   |
| 61	| wait4  |   等待一个进程终止             |
| 62	| kill   |  发送信号到一个进程            |







示例：

```C
//常见的 printf “hello, world” 用write写

int main()
{
    // 第一个参数将输出发送到 stdout，第二个参数是要写的字节序列，第三个参数是要写的字节数
    write(1, "hello, world\n", 13);
    _exit(0);
}
```









## 进程

>  异常时允许操作系统内核提供进程(process)概念的基本构造块，进程是计算机科学中最深刻、最成功的概念之一。  

进程典型定义就是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文（context）中。上下文是由程序正确运行所需的状态组成的，包括存放在内存中程序的代码和数据，栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。  

操作系统提供给应用程序的关键抽象：

* 一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器
* 一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统



### 逻辑控制流

如果用调试器单步执行程序，会看到一系列程序计数器（PC）的值，这些值唯一的对应于包含在程序可执行目标文件中的指令，或者是包含在运行时动态链接到程序的共享对象的指令。  

程序计数器（PC）的序列叫做逻辑控制流，或者简称逻辑流。  

进程轮流使用处理器，每个进程执行它流的一部分，然后被抢占（preempted）暂时挂起，然后轮到其它进程。





### 并发流

逻辑流有许多不同的形式。异常处理程序、进程、信号处理程序、现成、java进程都是例子。  

一个逻辑流的执行在时间上与另一个流重叠，称为并发流（concurrent flow）。多个流并发地执行的现象被称为并发（concurrency）。一个进程和其他进程轮流运行的概念称为多任务（multitasking）。一个进程执行它的控制流的一部分的每一时间段叫时间片（time slice）。因此，多任务也叫做时间分片（time slicing）。  

如果两个流并发地运行在不同的处理器核或者计算机上，那么称为并行流（parallel flow），它们并行地运行（runnning in parallel），且并行地执行（parallel execution）。  







### 私有地址空间

进程也为每个程序提供一种假象，好像它独占地使用系统地址空间。它为每个程序提供它自己的私有地址空间。一般而言，和这个空间中某个地址相关联的那个内存字节是不能被其他进程读或者写的。  

和每个私有地址空间相关联的内存内容一般是不同的，但空间都有相同的通用结构。

* 用户栈
* 共享库的内存映射区域
* 运行时堆
* 读/写段
* 只读代码段



### 用户模式和内核模式

处理器通常是用某个控制寄存器中的一个模式位（mode bit）来提供功能，限制应用可以执行的指令以及它可以访问的地址空间范围。  该寄存器描述了当前进程享有的特权。   

当设置了模式位时，进程就运行在内核模式中（有时叫做超级用户模式）。 一个运行在内核模式中的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置。  

当没有设置模式位时，进程就运行在用户模式。不允许执行特权指令（privileged instruction），例如停止处理器、改变模式位、或者发起I/O 操作。也不允许用户模式中的进程直接引用地址空间中内核区的代码和数据。任何这样的尝试都会导致致命的保护故障。



用户模式变为内核模式的唯一方法是通过诸如中断、故障、陷入系统调用这样的异常。  

Linux 提供了 `/proc` 文件系统，允许用户模式进程访问内核数据结构的内容。例如 /proc/cpuinfo、/proc/<process-id>/maps 等，Linux 内核版本 2.6 以后引入了 /sys 文件系统，输出关于系统总线和设备的额外的低层信息。  









### 上下文切换

操作系统内核使用上下文切换（context switch）的较高层形式的异常控制流来实现多任务，此机制是建立在较低层的异常机制之上的。  

内核为每个进程维持一个上下文（context），它由一些对象的值组成，包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和内核数据结构（比如描述地址空间的页表、包含当前进程信息的进程表，以及包含进程已打开文件的信息的文件表）。  

内核中调度器（scheduler）决策抢占当前进程，并重新开始一个先前被抢占的进程。调度器使用上下文切换机制来将控制转移到新的进程。

1. 保存当前进程的上下文
2. 恢复某个先前被强占的进程被保存的上下文
3. 将控制传递给这个新恢复的进程







## 系统调用错误处理

当 Unix 系统级函数遇到错误时，通常会返回 -1，并设置全局整数变量 errno 来表示错误类型。  

示例，调用 Unix fork 函数时进行错误检查：

```C
	if((pid = fork()) < 0){
        fprintf(stderr, "fork error: %s\n", strerror(errno));
        exit(0);
    }
```

可以定义一个错误报告函数，能够一定程度上简化代码：

```C
void unix_error(char *msg){
    fprintf(stderr, "%s, %s\n", msg, strerror(errno));
    exit(0);
}

// 调用上面的函数
if((pid = fork()) < 0){
    unix_error("fork error");
}
```

对于给定的基本函数，可以定义一个有相同参数的包装函数，第一个字母大写，包装函数调用基本函数，并进行错误检查：

```C
pid_t Fork(void){
    pid_t pid;
    
    if((pid = fork()) < 0)
        unix_error("Fork error");
    return pid;
}
```

这样对 fork 的调用就缩减为 1 行：

```C
pid = Fork();
```







## 进程控制

Unix 提供了大量从 C 程序中操作进程的系统调用



### 获取进程 ID

每个进程都有一个唯一的正数（非零）进程 ID（PID）。getpid 函数返回调用进程的 PID。getppid 函数返回它的父进程的 PID（创建调用进程的进程）。

```C
#include <sys/types.h>
#include <unistd.h>

pid_t getpid(void);
pid_t getppid(void);


```





### 创建和终止进程

从程序员角度，进程总处于下面三种状态之一：

* 运行：在CPU 上执行，或者等待被执行且最终会被内核调度
* 停止：被挂起（suspended），且不会被调度。当收到 SIGSTOP、SIGTSTP、SIGTTOU 信号时，进程就停止，并保持停止知道它收到一个 SIGCONT 信号，这个时刻，进程再次开始运行。
* 终止：进程永远地停止了。主要有三种原因：
  * 收到终止进程信号
  * 从主程序返回
  * 调用 exit 函数



exit 函数以 status 退出状态来终止进程：

```C
#include <stdlib.h>
void exit(int status);
```



fork 函数创建一个新的运行的子进程：

```C
#include <sys/types.h>
#include <unistd.h>

pid_t fork(void);
```

新创建的子进程和父进程几乎相同。子进程得到与父进程用户级虚拟地址空间相同的一份副本，包括代码和数据段、堆、共享库、用户栈。还会获得父进程任何打开文件描述符相同的副本，这样子进程可以读写父进程中打开的任何文件。父子进程最大的区别在于他们有不同的 PID。  

fork 函数调用一次，返回两次：一次是在父进程中，一次是在新创建的子进程中。父进程中，fork 返回子进程的 PID，子进程中，fork 返回 0。返回值可以区分程序是在父进程还是子进程中执行。

示例：

```C
int main(){
    pid_t pid;
    int x = 1;
    
    pid = Fork();
    if (pid == 0){
        printf("Child process: x=%d\n", ++x);
        exit(0);
    }
    
    printf("Parent: x=%d\n", --x);
    exit(0);
    
}
```

上述示例有一些要注意的地方：

* 调用一次，返回两次，当有多个 fork 实例时，需要仔细地推敲
* 并发执行，子进程和父进程是并发运行的独立进程。一般而言，不能对他们之间代码指令执行顺序进行任何假设
* 相同但是独立的地址空间。在 fork 后的时刻父子进程地址空间都是相同的，但随着程序运行，父子进程中对各自的变量、堆等内容会发生不同的变化
* 共享文件。例如示例中父子进程 stdout 文件都是打开且指向屏幕，输出也都打印到屏幕中了。



示例：第二行中父进程fork出一个子进程，父子进程都会在第三行再次fork出一个子进程，同时有四个进程会打印第四行的 printf 语句然后退出。

```C
int main(){
    Fork();
    Fork();
    printf("hello\n");
    exit(0);
}
```



### 回收子进程

当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除，进程会被保持在一种已终止的状态，直到被它的父进程回收（reaped）。父进程回收已终止的进程时，内核将子进程的退出状态传递给父进程然后抛弃已终止的进程。一个已终止但未被回收的进程称为僵死进程（zombie）。  

如果一个父进程终止了，内核会安排 init 进程成为它的孤儿进程的养父。init 进程的 PID 为 1，是在系统启动时由内核创建的，他不会终止，是所有进程的祖先。  

一个进程可以通过调用 waitpid 函数来等待它的子进程终止或者停止。  

```C
#include <sys/types.h>
#include <sys/wait.h>

pid_t waitpid(pid_t pid, int *statusp, int options);
```

返回值：

* 如果成功，返回子进程的 PID，如果 WNOHANG，返回 0，如果其他错误，则返回 -1
* 默认情况下（当 option = 0 时），waitpid 挂起调用进程执行，直到它的等待集合（wait set）中的一个子进程终止。
* 如果等待集合中的一个进程在刚调用的时候就已经终止了，那么 waitpid 就立即返回

参数：

* pid：判定等待集合的成员
* statusp：检查已回收子进程的退出状态
* options：修改默认行为





#### 判定等待集合的成员

等待集合的成员是由参数 pid 来确定的：

* 如果 pid > 0，那么等待集合就是一个单独的子进程，它的进程 ID 等于 pid
* 如果 pid = -1，那么等待集合就是由父进程所有的子进程组成的

#### 修改默认行为

可以通过将 options 设置为常量 WNOHANG、WUNTRACED、WCONTINUED 的各种组合来修改默认行为：

* WNOHANG：如果等待集合中的任何子进程都还没有终止，那么就立即返回（返回值为 0）
* WUNTRACED：挂起调用进程的执行，直到等待集合中的一个进程变成已终止或者被停止。返回的 PID 为导致返回的已终止或被停止子进程的 PID
* WCONTINUED：挂起调用进程的执行，直到等待集合中一个正在运行的进程终止或等待集合中一个被停止的进程收到 SIGCONT 信号重新开始执行。

可以用运算把这些选项组合起来，例如：

* WNOHANG | WUNTRACED：立即返回，如果等待集合中的子进程都没有被停止或终止，则返回值为 0； 如果有一个停止或终止，则返回值为该子进程的 PID



#### 检查已回收子进程的退出状态

如果 statusp 参数是非空的，那么 waitpid 就会在 status 中放上关于导致返回的子进程的状态信息， status 是 statusp 指向的值。wait.h 头文件定义了解释 status 参数的几个宏：

* WIFEXITED：子进程通过调用 exit 或者返回（return） 正常终止，返回真
* WEXITSTATUS：返回退出状态，只有 WIFEXITED() 返回为真时才会定义这个状态
* WIFSIGNALED：子进程因为一个违背捕获的信号终止的，则返回真
* WTERMSIG：导致子进程终止的信号的编号，只有 WIFSIGNALED() 返回为真，才定义这个状态
* WIFSTOPPED：如果引起返回的子进程当前是停止的，那么就返回真
* WSTOPSIG：返回引起子进程停止的信号的编号，只有在 WIFSTOPPED()返回为真，才定义这个状态
* WIFCONTINUED：如果子进程收到 SIGCONT 信号重新启动，则返回真



#### 错误条件

如果调用进程没有子进程，那么 waitpid 返回 -1，并设置 errno 为 ECHILD。如果 waitpid 函数被一个信号中断，那么它返回 -1，并设置 errno 为 EINTER。



#### wait 函数

wait 函数是 waitpid 函数的简单版本

```C
#include <sys/types.h>
#include <sys/wait.h>

pid_t wait(int *statusp);

```

调用 wait(&status) 等价于调用 waitpid(-1, &status, 0)。







#### 示例



父进程创建若干子进程，等待子进程结束回收：

```C
#include <stdio.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>

#define N 2

void unix_error(char *msg){
    fprintf(stderr, "%s, %s\n", msg, strerror(errno));
    exit(0);
}

int main(){
    int status, i;
    pid_t pid;

    for (i = 0 ; i < N; i++)
        if ((pid = fork()) == 0) 
            exit(100 + i);

    while((pid = waitpid(-1, &status, 0)) > 0){
        if(WIFEXITED(status))
            printf("child %d terminated with exit status %d\n", pid, WEXITSTATUS(status));
        else
            printf("child %d terminated abnormally\n", pid);
    
    }

    if (errno != ECHILD)
        unix_error("waitpid error");

    exit(0);

}
```



父进程存储子进程 PID 到数组中，按照创建子进程的顺序回收：

```C
#include <stdio.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>

#define N 2

void unix_error(char *msg){
    fprintf(stderr, "%s, %s\n", msg, strerror(errno));
    exit(0);
}

int main(){
    int status, i;
    pid_t pids[N], retpid;

    for (i = 0 ; i < N; i++)
        if ((pids[i] = fork()) == 0) 
            exit(100 + i);

    i = 0;
    while((retpid = waitpid(pids[i++] , &status, 0)) > 0){
        if(WIFEXITED(status))
            printf("child %d terminated with exit status %d\n", retpid, WEXITSTATUS(status));
        else
            printf("child %d terminated abnormally\n", retpid);
    
    }

    if (errno != ECHILD)
        unix_error("waitpid error");

    exit(0);

}
```









### 进程休眠

sleep 函数将一个进程挂起一段指定的时间

```C
#include <unistd.h>

unsigned int sleep(unsigned int secs);
```

时间量到了以后，sleep 返回 0，否则返回剩下要休眠的秒数（如果 sleep 函数被一个信号中断而过早返回会出现这种情况）。  

pause 函数会让调用函数休眠，直到该进程收到一个信号：

```C
#include <unistd.h>
int pause(void);
```







### 加载并运行程序

execve 函数在当前进程的上下文中加载并运行一个新程序

```C
#include <unistd.h>

int execve(const char *filename, const char *argv[], const char *envp[]);
```

* filename 是可执行目标文件，argv 是参数列表， envp 是环境变量列表
* 出现错误 execve 才会返回到调用程序
* execve 调用一次并从不返回
* argv 变量指向一个以 null 结尾的指针数组，每个指针指向一个参数字符串，按照惯例 argv[0] 是可执行目标文件的名字
* envp 变量是一个以 null 结尾的指针数组，每个指针指向一个环境变量字符串，每个串以“name=value”形式



execve 加载了 filename 之后，会调用启动代码，启动代码设置栈，并将控制传递给新程序的主函数，主函数形式如下：

```C
int main(int argc, char **argv, char **envp);

// 或者另一种形式
int main(int argc, char *argv[], char *envp[]);

```

main 函数3个参数：argc 为 argv[] 数组中非空指针数量，argv 参数指向 argv[] 数组中第一个条目，envp 指向 envp[] 数组中第一个条目



Linux 提供了修改才做环境数组的函数：  

getenv 函数在环境数组中搜索字符串“name=value”，找到就返回指向 value 的指针，否则返回 NULL

```C
#include <stdlib.h>

char *getenv(const char *name);
```



setenv 函数设置新的值（overwrite参数要为非零），unsetenv 删除现有的值

```C
#include <stdlib.h>

int setenv(const char *name, const char *newvalue, int overwrite);

void unsetenv(const char *name);
```









### 利用 fork 和 execve 运行程序



一个简单的 shell 的示例，解析用户输入的内容，如果是文件名就执行，quit 则退出：

```C
#include <stdio.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <fcntl.h>

#define MAXARGS 128
#define MAXLINE 1024

extern char **environ;

void eval(char *cmdline);
int parseline(char *buf, char **argv);
int builtin_command(char **argv);

int main()
{
    char cmdline[MAXLINE];

    while (1)
    {
        printf(">");
        fgets(cmdline, MAXLINE, stdin);
        if (feof(stdin))
            exit(0);

        eval(cmdline);
    }
}

void unix_error(char *msg)
{
    fprintf(stderr, "%s, %s\n", msg, strerror(errno));
    exit(0);
}

pid_t Fork(void){
    pid_t pid;
    
    if((pid = fork()) < 0)
        unix_error("Fork error");
    return pid;
}

void eval(char *cmdline)
{
    char *argv[MAXARGS];
    char buf[MAXLINE];
    int bg;
    pid_t pid;

    strcpy(buf, cmdline);
    bg = parseline(buf, argv);
    if (argv[0] == NULL)
        return;

    if (!builtin_command(argv))
    {
        if ((pid = Fork()) == 0)
        {
            if (execve(argv[0], argv, environ) < 0)
            {
                printf("%s: Command not found.\n", argv[0]);
                exit(0);
            }
        }

        if (!bg)
        {
            int status;
            if (waitpid(pid, &status, 0) < 0)
                unix_error("waitfg: waitpid error");
        }
        else
            printf("%d %s", pid, cmdline);
    }
    return;
}

int builtin_command(char **argv)
{
    if (!strcmp(argv[0], "quit"))
        exit(0);
    if (!strcmp(argv[0], "&"))
        return 1;

    return 0;
}

int parseline(char *buf, char **argv)
{
    char *delim;
    int argc;
    int bg;

    buf[strlen(buf) - 1] = ' ';
    while (*buf && (*buf == ' '))
        buf++;

    argc = 0;
    while ((delim = strchr(buf, ' ')))
    {
        argv[argc++] = buf;
        *delim = '\0';
        buf = delim + 1;
        while (*buf && (*buf == ' '))
            buf++;
    }

    argv[argc] = NULL;

    if (argc == 0)
        return 1;

    if ((bg = (*argv[argc - 1] == '&')) != 0)
        argv[--argc] = NULL;

    return bg;
}
```











## 信号

Linux 系统上支持 30 种不同类型的信号。

| 序号    |   名称   |   默认行为   |  相应事件  |
| ---- | ---- | ---- | ---- |
| 1	 	|	SIGHUP		| 终止					|	终端线挂断					|
| 2		|	SIGINT		| 终止					|	来自键盘的中断                |
| 3	 	|	SIGQUIT   	| 终止					|	来自键盘的退出                |
| 4	 	|	SIGILL		| 终止					|	非法指令                     |
| 5	 	|	SIGTRAP   	| 终止并转储内存?			|	跟踪陷阱                     |
| 6	 	|	SIGABRT   	| 终止并转储内存			|	来自abort函数的终止信号        |
| 7	 	|	SIGBUS		| 终止					|	总线错误                     |
| 8	 	|	SIGFPE		| 终止并转储内存			|	浮点异常                     |
| 9	 	|	SIGKILL   	| 终止					|	杀死程序                     |
| 10	|  	SIGUSR1  	| 终止					|	用户定义的信号1               |
| 11	|  	SIGSEGV  	| 终止并转储内存			|	无效的内存引用（段故障）         |
| 12	|  	SIGUSR2  	| 终止					|	用户定义的信号2               |
| 13	|  	SIGPIPE  	| 终止					|	向一个没有读用户的管道做写操     |
| 14	|  	SIGALRM  	| 终止					|	来自alarm函数的定时器信号       |
| 15	|  	SIGTERM  	| 终止					|	软件终止信号                  |
| 16	|  	SIGSTKFLT	| 终止					|	协处理器上的栈故障             |
| 17	|  	SIGCHLD		| 忽略					|	一个子进程停止或者终止          |
| 18	|  	SIGCONT		| 忽略					|	继续进程如果该进程停止          |
| 19	|  	SIGSTOP		| 停止直到下一个SIGCONT?	|	不是来自终端的停止信号          |
| 20	|  	SIGTSTP		| 停止直到下一个SIGCONT	|	来自终端的停止信号             |
| 21	|  	SIGTTIN		| 停止直到下一个SIGCONT	|	后台进程从终端读               |
| 22	|  	SIGTTOU		| 停止直到下个SIGCONT		|	后台进程向终端写               |
| 23	|  	SIGURG		| 忽略					|	套接字上的紧急情况             |
| 24	|  	SIGXCPU		| 终止					|	CPU时间限制超出               |
| 25	|  	SIGXFSZ		| 终止					|	文件大小限制超出               |
| 26	|  	SIGVTALRM	| 终止					|	虚拟定时器期满                |
| 27	|  	SIGPROF		| 终止					|	剖析定时器期满                |
| 28	| 	SIGWINCH	| 忽略					|	窗口大小变化                  |
| 29	|  	SIGIO		| 终止					|	在某个描述符上可执行I/O操作      |
| 30	|  	SIGPWR		| 终止					|	电源故障                     |










### 信号术语

传送一个信号到目的进程由两个步骤组成

* 发送信号：内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程，有两种原因：
  * 内核检测到一个系统事件，比如除零或者子进程终止
  * 一个进程调用了 kill 函数，显式地要求内核发送一个信号给目的进程，一个进程也可以发送信号给自己
* 接收信号：当目的进程被内核强迫以某种方式对信号的发送作出反应时，它就接收了信号，进程可以忽略、终止或者执行一个__信号处理程序__（signal handler）的用户层函数捕获这个信号



一个发出而没有被接收的信号叫做__待处理信号(pending signal)__。在任何时刻，一种类型至多只会有一个待处理信号。如果一个进程有一个类型为 k 的待处理信号，那么任何接下来发送到这个进程的类型为 k 的信号都不会排队等待，它们只是被简单地丢弃。  

一个进程可以有选择地阻塞接收某种信号。当一种信号被阻塞时，它仍可以被发送，但产生的待处理信号不会被接收，直到进程取消对这种信号的阻塞。  

一个待处理信号最多只能被接收一次。内核为每个进程在 pending 位向量中维护着待处理信号的集合，而在 blocked 位向量中维护者被阻塞的信号集合。只要传送了一个类型为 k 的信号，内核就会设置 pending 中的 k 位，而只要接收了一个类型为 k 的信号，内核就会清除 pending 中的第 k 位。  



### 发送信号

Unix 系统提供了大量向进程发送信号的机制，这些机制都是基于进程组（process group）这个概念的。

#### 进程组

* 每个进程都只属于一个进程组
* 进程组由一个正整数进程组 ID 来标识



getpgrp 函数返回当前进程的进程组 ID

```C
#include <unistd.h>

pid_t getpgrp(void);
```

默认地，一个子进程和它的父进程同属于一个进程组。一个进程可以通过调用 setpgid 函数来改变自己或其他进程的进程组：

```C
#include <unistd.h>

int setpgid(pid_t pid, pid_t pgid);
```

setpgid 函数将进程 pid 的进程组改为 pgid。

* 如果 pid 是 0，那么就是用当前进程的 PID。 
* 如果 gpid 是 0，那么就用指定的进程的 PID 作为进程组 ID
* 例如进程 15213 是调用进程，`setpgid(0,0)` 会创建一个进程组，ID 是 15213，并且把进程 15213 加入到这个新的进程组中。



#### 用 /bin/kill 程序发送信号

例如：

```bash
linux> kill -9 15213
linux> kill -15 15213
```

#### 从键盘发送信号

例如：

* Ctrl+C 发送 SIGINT，终止前台作业进程
* Ctrl+Z 发送 SIGTSTP，挂起前台作业进程



#### 用 kill 函数发送信号

进程通过调用 kill 函数发送信号给其它进程（包括它们自己）

```C
#include <sys/types.h>
#include <signal.h>

int kill(pid_t pid, int sig);
```

* 如果参数 pid 大于零，那么 kill 函数发送信号号码 sig 给进程 pid
* 如果 pid 等于零，那么 kill 发送信号 sig 给调用进程所在进程组中的每个进程，包括调用进程自己
* 如果 pid 小于零，kill 发送信号 sig 给进程组 |pid|(pid 的绝对值)中的每个进程

示例：

```C
#include <stdio.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <signal.h>


void unix_error(char *msg){
    fprintf(stderr, "%s, %s\n", msg, strerror(errno));
    exit(0);
}

pid_t Fork(void){
    pid_t pid;
    
    if((pid = fork()) < 0)
        unix_error("Fork error");
    return pid;
}

int main(){
    pid_t pid;

    if ((pid = Fork()) == 0 ){
        printf("Child process %d created, waiting for signal...\n", getpid());
        pause();
        printf("control should never reach here!\n");
        exit(0);
    }

    sleep(1);

    printf("Parent process %d sending SIGKILL to child process %d\n", getpid(), pid);
    kill(pid, SIGKILL);
    exit(0);
}
```





#### 用 alarm 函数发送信号

进程可以通过调用 alarm 函数向它自己发送 SIGALRM 信号：

```C
#include <unistd.h>

unsigned int alarm(unsigned int secs);
```

alarm 函数安排内核在 secs 秒后发送一个 SIGALRM 信号给调用程序。

* 如果 secs 是零，那么不会调度安排新的闹钟（alarm）
* 任何情况下，对 alarm 的调用都将取消任何待处理（pending）闹钟，并且返回任何待处理的闹钟在被发送前还剩下的秒数，如果没有任何待处理的闹钟就返回零





### 接收信号



每个信号类型都有一个预定义的默认行为，下面中的一种：

* 进程终止
* 进程终止并转储内存
* 进程停止（挂起）直到被 SIGCONT 信号重启
* 进程忽略该信号

除了 SIGSTOP 和 SIGKILL，这两个信号的默认行为是不能被修改的。  





```C
#include <signal.h>
typedef void(*sighandler_t)(int);

sighandler_t signal(int signum, sighandler_t handler);
```

signal 函数可以通过三种方法之一改变和信号 signum 相关联的行为：

* 如果 handler 是 SIG_IGN，那么忽略类型为 signum 的信号
* 如果 handler 是 SIG_DFL，那么类型为 signum 的信号行为恢复为默认行为
* 否则，handler 就是用户定义的函数的地址，这个函数被称为 信号处理程序，只要进程接收到一个类型为 signum 的信号，就会调用这个程序。  
  * 通过把处理程序的地址传递到 signal 函数从而改变默认行为，这叫做设置信号处理程序（installing the handler）
  * 调用信号处理程序被称为捕获信号
  * 执行信号处理程序被称为处理信号

当一个进程捕获了一个类型为 k 的信号时，会调用为信号 k 设置的处理程序，一个整数参数被设置为 k，这个参数允许同一个处理程序捕获不同类型的信号。



捕获 SIGINT 信号的示例：

```C
#include <stdio.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <signal.h>

void unix_error(char *msg){
    fprintf(stderr, "%s, %s\n", msg, strerror(errno));
    exit(0);
}


void signal_handler_jerry(int sig){
    printf("Caught SIGINT\n");
    exit(0);
}

int main(){

    if (signal(SIGINT, signal_handler_jerry) == SIG_ERR)
        unix_error("signal error");

    pause();

    return 0;
}
```





### 阻塞和解除阻塞信号

Linux 提供阻塞信号的隐式和显式的机制：

* 隐式阻塞机制。内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号
* 显式阻塞机制。应用程序可以使用 sigprocmask 函数和它的辅助函数，明确地阻塞和解除阻塞选定的信号



```C
#include <signal.h>

int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
int sigemptyset(sigset_t *set);
int sigfillset(sigset_t *set);
int sigaddset(sigset_t *set, int signum);
int sigdelset(sigset_t *set, int signum);
// 返回值：如果成功则为0，若出错则为 -1

    
int sigismember(const sigset_t *set, int signum);
// 返回值：若 signum 是 set 的成员则为 1，如果不是则为 0，若出错则为 -1.
```

sigprocmask 函数改变当前阻塞的信号集合，具体的行为依赖于 how 的值：

* SIG_BLOCK：把 set 中的喜好添加到 blocked 中（blocked=blocked | set）
* SIG_UNBLOCK：从 blocked 中删除 set 中的信号（blocked=blocked &~set）
* SIG_SETMASK：block=set



示例，临时阻塞接收 SIGINT 信号：

```C
sigset_t mask, prev_mask;

// 初始化 set 集合为空
Sigemptyset(&mask);
Sigaddset(&mask, SIGINT);

// 阻塞 SIGINT，保存前一个 blocked set
Sigprocmask(SIG_BLOCK, &mask, &prev_mask);

// 这里的代码不会被 SIGINT 信号中断

// 恢复前一个 blocked set，取消阻塞 SIGINT 信号
Sigprocmask(SIG_SETMASK, &prev_mask, NULL);
```





### 编写信号处理程序

* 信号处理程序与主程序并发运行，共享同样的全局变量，因此可能与逐层许和其他处理程序互相干扰
* 如何以及何时接收信号的规则常常有违人的直觉
* 不同的系统有不同的信号处理语义



#### 安全的信号处理

* G0. 处理程序要尽可能简单。
* G1. 在处理程序中只调用异步信号安全的函数，异步信号安全的函数：要么是可重入的，要么是它不能被信号处理程序中断。
  * 例如 printf、sprintf 是不安全的
  * 产生输出的唯一安全方法是使用 write 函数
* G2. 保存和回复 errno。
* G3. 阻塞所有的信号，保护对共享全局数据结构的访问。
* G4. 用 volatile 声明全局变量。
* G5. 用 sig_atomic_t 声明标志。



#### 正确的信号处理

* 未处理的信号是不排队的，因为 pending 位向量中每种类型的信号只有一位，因此最多只能有一个未处理的信号。
* 不可以用信号来对进程中发生的事件计数







#### 可移植的信号处理

* signal 函数的语义在不同系统中各不相同

* 系统调用可以被中断

* Posix 标准定义了 sigaction 函数，允许用户设置信号处理时，明确指定想要的信号处理语义

  * 它要求用户设置一个复杂结构的条目，因此运用并不广泛

  * ```C
    #include <signal.h>
    
    int sigaction(int signum, struct sigaction *act, struct sigaction *oldact);
    ```

  * 

* 另一种简洁的方式，就是定义包装函数，它调用 sigaction

  * ```C
    handler_t *Signal(int signum, handler_t *handler) 
    {
        struct sigaction action, old_action;
    
        action.sa_handler = handler;  
        sigemptyset(&action.sa_mask); /* Block sigs of type being handled */
        action.sa_flags = SA_RESTART; /* Restart syscalls if possible */
    
        if (sigaction(signum, &action, &old_action) < 0)
    		unix_error("Signal error");
        return (old_action.sa_handler);
    }
    ```

  * 其信号处理语义如下：

  * 只有这个处理程序当前正在处理的那种类型的信号被阻塞

  * 和所有信号实现一样，信号不会排队等待

  * 只要可能，被中断的系统调用会自动重启

  * 一旦设置了信号处理程序，他就会一直保持，直到 Signal 带着 handler 参数为 SIG_IGN 或者 SIG_DFL 被调用







### 同步流以避免讨厌的并发错误

父进程和子进程之间在同步运行信号处理流时会出现交错，竞争（race）资源，执行顺序无法保证，要仔细小心地使用。



### 显式地等待信号

有时候主程序需要显式地等待某个信号处理程序运行。，例如 Linux shell 创建一个前台作业，在接收下一条用户命令前，必须等待作业终止，被 SIGCHLD 处理程序回收。  



sigsuspend 函数：

```C
#include <signal.h>

int sigsuspend(const sigset_t *mask);
```

sigsuspend 函数暂时用 mask 替换当前的阻塞集合，然后挂起该进程，直到收到一个信号，其行为要么是运行一个处理程序，要么是终止程序。

* 如果它的行为是终止，那么该进程不从 sigsuspend 返回就直接终止
* 如果它的行为是运行一个处理程序，那么 sigsuspend 从处理程序返回，恢复调用 sigsuspend 时原有的阻塞集合





## 非本地跳转

C 语言提供了一种用户级异常控制流形式，称为__非本地跳转(nonlocal jump)__，它将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的 调用-返回序列。非本地跳转是通过 setjmp 和 longjmp 函数提供的。  



```C
#include <setjmp.h>

int setjmp(jmp_buf env);
int sigsetjmp(sigjmp_buf env, int savesigs);
```

setjmp 函数在 env 缓冲区中保存当前调用环境，以供后面的 longjmp 使用，并返回0。调用环境包括程序计数器、栈指针、通用目的寄存器。它的返回值不能被赋值给变量，但可以安全的用在 switch 或条件语句的测试中。



```C
#include <setjmp.h>

void longjmp(jmp_buf env, int retval);
void siglongjmp(sigjmp_buf env, int retval);
```

longjmp 函数从 env 缓冲区中恢复调用环境，然后触发一个从最近一次初始化 env 的 setjmp 调用的返回。然后 setjmp 返回，并带有非零的返回值 retval。



* setjmp 函数只被调用一次，但返回多次
  * 一次是当第一次调用 setjmp，而调用环境保存在缓冲区 env 中时
  * 一次是为每个相应的 longjmp 调用
* longjmp 函数被调用一次，但从不返回



非本地跳转的一个重要应用就是允许从一个深层嵌套的函数调用中立即返回，通常是检测到某个错误情况引起的。



示例，main 函数调用 setjmp 保存调用环境，然后调用 foo，foo调用bar，如果foo或者bar出现错误，它们立即通过一次 longjmp 调用从 setjmp 返回，setjmp 的非零返回值指明了错误类型，可以被解码，然后进行处理：

```C
#include <setjmp.h>
#include <stdio.h>
#include <stdlib.h>

jmp_buf buf;

int error1 = 1;
int error2 = 0;

void foo(void), bar(void);

int main(){
    switch(setjmp(buf)){
        case 0:
            foo();
            break;
        case 1:
            printf("error1 occurred\n");
            break;
        case 2:
            printf("error2 occurred\n");
            break;
        default:
            printf("unknown error\n");
    }
    exit(0);

}

void foo(){
    if (error1)
        longjmp(buf, 1);
    bar();
}

void bar(){
    if(error2)
        longjmp(buf, 2);
}
```

longjmp 允许它跳过所有中间调用的特性可能产生意外的后果。例如，中间函数产生的某些数据结构，在函数结尾才会被回收，那么这些回收会被跳过从而产生内存泄漏。  

非本地跳转另一个重要应用时使信号处理程序分支到一个特殊的代码位置，而不是返回到被信号到达中断了的指令的位置。  

sigsetjmp 和 siglongjmp 函数是 setjmp 和 longjmp 的可以被信号处理程序使用的版本。  



示例，当程序第一次运行，通过 sigsetjmp 设置保存环境信息，随后进入循环，当用户 Ctrl+C 时，内核发送 SIGINT 信号给进程，进程捕获到这个信号，不从信号处理程序返回，而是通过处理程序完成一个非本地跳转，回到 main 函数开始处：

```C
#include <setjmp.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

ssize_t sio_puts(char s[]){
    return write(STDOUT_FILENO, s, strlen(s));
}

jmp_buf buf;

void handler(int sig){
    siglongjmp(buf, 1);
}

int main(){
    if (!sigsetjmp(buf,1)){
        signal(SIGINT, handler);
        sio_puts("starting...\n");
    }
    else{
        sio_puts("restarting...\n");
    }

    while(1){
        sleep(1);
        sio_puts("processing...\n");
    }

    exit(0);
}
```

运行示例程序：

```bash
./restart 
starting...
processing...
processing...
processing...
^Crestarting...
processing...
processing...
processing...
^Crestarting...
processing...
processing...

```

sigsetjmp 和 siglongjmp 不是异步信号安全的函数，因为 siglongjmp

可以跳转到任意代码，因此必须小心，只在 siglongjmp 可达的代码中调用安全的函数。







## 操作进程的工具

* STRACE：打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。
* PS：列出当前系统中的进程（包括僵死进程）
* TOP：打印当前系统中进程资源使用的信息
* PMAP：显示进程的内存映射
* /proc：一个虚拟文件系统，以 ASCII 文本格式输出大量内核数据结构的内容，用户程序可以读取这些内容。例如 `cat /proc/loadavg` 可以查看 Linux 系统当前的平均负载