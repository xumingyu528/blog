---
title: CSAPP-汇编指令

---

最近在看 CSAPP 这本书，第三章里汇编相关内容比较多，不容易记住，整理一份常见的，方便记忆和查找。





## 数据格式



| C 声明 | Intel 数据类型 | 汇编代码后缀 | 大小(字节) |
| ------ | -------------- | ------------ | ---------- |
| char   | 字节           | b            | 1          |
| short  | 字             | w            | 2          |
| int    | 双字           | l            | 4          |
| long   | 四字           | q            | 8          |
| char*  | 四字           | q            | 8          |
| float  | 单精度         | s            | 4          |
| double | 双精度         | l            | 8          |




## 访问信息
### 整数寄存器

16个寄存器

| 64位 | 32位  | 16位  | 8位   |                                                    |
| ---- | ----- | ----- | ----- | -------------------------------------------------- |
| %rax | %eax  | %ax   | %al   | 返回值，原本含义是累加器 Accumulator               |
| %rbx | %ebx  | %bx   | %bl   | 被调用者保存，原本含义是基地址 Base                |
| %rcx | %ecx  | %cx   | %cl   | 第4个参数，原本含义是计数器 Counter                |
| %rdx | %edx  | %dx   | %dl   | 第3个参数，原本含义是数据 Data                     |
| %rsi | %esi  | %si   | %sil  | 第2个参数，原本含义是源 Source                     |
| %rdi | %edi  | %di   | %dil  | 第1个参数，原本含义是目的 Destination              |
| %rbp | %ebp  | %bp   | %bpl  | 被调用者保存，原本含义是 栈基址 Stack Base Pointer |
| %rsp | %esp  | %sp   | %spl  | 栈指针 Stack Pointer                               |
| %r8  | %r8d  | %r8w  | %r8b  | 第5个参数                                          |
| %9   | %r9d  | %r9w  | %r9b  | 第6个参数                                          |
| %10  | %r10d | %r10w | %r10b | 调用者保存                                         |
| %11  | %r11d | %r11w | %r11b | 调用者保存                                         |
| %12  | %r12d | %r12w | %r12b | 被调用者保存                                       |
| %13  | %r13d | %r13w | %r13b | 被调用者保存                                       |
| %14  | %r14d | %r14w | %r14b | 被调用者保存                                       |
| %15  | %r15d | %r15w | %r15b | 被调用者保存                                       |



### 操作数指示符

操作数可以使立即数（常数）值、寄存器值、内存值



* 立即数 Immediate $Imm，例如 $2 代表目标操作数是 2
* 寄存器 例如 %rax，表示目标操作数是 %rax 中存储的数
* 存储器 Imm(ra,rb,s),Imm + ra + rb*s
  * ra 是基址
  * rb 是变址
  * s是比例因子，必须是 1、2、4、8
  * Imm 是立即数偏移量，要注意16进制或者10进制标识
  * 示例：0xA0(%rax,%rdx,4)，rax寄存器中值为0x100,0x100内存地址中值为0xFF，rdx寄存器中值为0x3，操作数为 0xA0 + 0xFF + 0x3*4 = 0xA0 + 0xFF + 0xC = 0x1AB



### 数据传送指令

#### MOV 指令

* movb 传送字节
* movw 传送字
* movl 传送双字
* movq 传送四字
* movabsq 传送绝对的四字



将较小的源值复制到较大的目的时，根据有无符号填充高位的剩余地址，分为2类，零扩展将剩余字节扩展填充为0，符号扩展将源地址最高位复制填充到剩余字节

* MOVZ 零扩展
  * movzbw 字节传送到字
  * movzbl 字节传送到双字
  * movzwl 字传送到双字
  * movzbq 字节传送到四字
  * movzwq 字传送到四字
* MOVS 符号扩展
  * movsbw 字节传送到字
  * movsbl 字节传送到双字
  * movswl
  * movsbq 字节传送到四字
  * movswq
  * movslq
  * cltq 符号扩展 %eax 寄存器到 %rax 寄存器



### 压入和弹出栈数据

#### push、pop



栈遵循后进先出，从内存地址高位自上而下，即后来的数据存放地址要小于先来的，有2个相关指令，栈指针%rsp保存着栈顶元素的地址

* push S，将源S中元素压入栈顶
  * 示例：pushq %rdi	将%rdi寄存器中4字大小数据压入栈
* pop D，将栈顶元素弹出到目的D
  * 示例：popq %rax 	将栈顶4字大小数据弹出到%rax寄存器





## 算术和逻辑操作

### 常见运算操作

除了`leaq` 指令外，其余指令都有加上不同大小操作数的后缀，例如 ADD指令有 addb、addw、addl、addq，分为四组操作：加载有效地址、一元操作、二元操作和移位，下表中S代表源，D代表目的，k代表移位数

#### leaq、inc、dec、neg、not、add、sub、imul、xor、or、and、sal、shl、sar、shr

| 指令                                                         | 效果                                                         | 描述                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| leaq  S,D                                                    | D <- &S                                                      | 加载有效地址                                                 |
| INC  D<br />DEC  D<br />NEG  D<br />NOT  D                   | D <- D+1<br />D <- D-1<br />D <- -D<br />D <- ~D             | 加1<br />减1<br />取负<br />取补                             |
| ADD  S,D<br />SUB  S,D<br />IMUL  S,D<br />XOR  S,D<br />OR  S,D<br />AND S,D | D <- D+S<br />D <- D-S<br />D <- D*S<br />D <- D^S<br />D <- D\|S<br />D <- D&S | 加<br />减<br />乘<br />异或<br />或<br />与                 |
| SAL  k,D<br />SHL  k,D<br />SAR  k,D<br />SHR  k,D           | D <- D<<k<br />D <- D<<k<br />D <- D>>k<br />D <- D>>k       | 左移<br />左移，等同于SAL<br />算术右移,高位填充符号位<br />逻辑右移,高位填充零 |



### 128位相关乘除法

两个64位有符号或无符号整数相乘的乘机需要128位来表示，x86-64 指令集对128位(16字节)数的操作提供有限的支持，16字节数称为八字(Oct word)，后缀为 `o`   

#### imulq、mulq、clto、idivq、divq

| 指令                  | 效果                                                         | 描述                           |
| --------------------- | ------------------------------------------------------------ | ------------------------------ |
| imulq  S<br />mulq  S | R[%rdx]：R[%rax] <- S * R[%rax]<br />R[%rdx]：R[%rax] <- S * R[%rax] | 有符号全乘法<br />无符号全乘法 |
| clto                  | R[%rdx]：R[%rax] <- 符号扩展(R[%rax])                        | 转换为八字                     |
| idivq  S              | R[%rdx] <- R[%rdx]：R[%rax] mod S<br />R[%rdx] <- R[%rdx]：R[%rax] ÷ S | 有符号除法                     |
| divq  S               | R[%rdx] <- R[%rdx]：R[%rax] mod S<br />R[%rdx] <- R[%rdx]：R[%rax] ÷ S | 无符号除法                     |

寄存器`%rdx`和`%rax`组成一个128位的八字





## 控制

### 条件码寄存器 condition code

#### CF、ZF、SF、OF

除了整数寄存器之外的

* CF：进位标志
* ZF：零标志，最近的操作得出结果为 0
* SF：符号标志
* OF：溢出标志



满足条件对应寄存器会被置为1，





算术和逻辑运算指令中除了 `leaq` 指令外，其余算术、逻辑、移位指令都会改变条件码标志，例如 

* XOR 将CF、OF设置为0
* 移位操作将 CF 设置为最后一个被移出的位，将 OF 设置为 0
* INC、DEC 指令设置ZF、OF，不会修改CF



### CMP 和 TEST 指令

CMP 类似于 SUB指令，TEST 类似于 AND 指令，这两个指令只设置条件码，不改变任何其他寄存器  



| 指令           | 基于    | 描述     |
| -------------- | ------- | -------- |
| CMP    S1, S2  | S2 - S1 |          |
| cmpb           |         | 比较字节 |
| cmpw           |         | 比较字   |
| cmpl           |         | 比较双字 |
| cmpq           |         | 比较四字 |
| TEST    S1, S2 | S1 & S2 |          |
| testb          |         | 测试字节 |
| testw          |         | 测试字   |
| testl          |         | 测试双字 |
| testq          |         | 测试四字 |



### SET 指令

后缀是表示不同的条件，不是操作数的大小

| 指令     | 同义名 | 效果              | 设置条件              |
| -------- | ------ | ----------------- | --------------------- |
| sete  D  | setz   | D <-  ZF          | 相等/零               |
| setne  D | setnz  | D <-  ~ZF         | 不等/非零             |
|          |        |                   |                       |
| sets  D  |        | D <-  SF          | 负数                  |
| setns  D |        | D <-  ~SF         | 非负数                |
|          |        |                   |                       |
| setg  D  | setnle | D <- ~(SF^OF)&~ZF | 大于 (有符号> )       |
| setge  D | setnl  | D <- ~(SF^OF)     | 大于等于 (有符号>= )  |
| setl  D  | setnge | D <- SF^OF        | 小于 (有符号< )       |
| setle  D | setng  | D <- (SF^OF)\|ZF  | 小于等于 (有符号<= )  |
|          |        |                   |                       |
| seta  D  | setnbe | D <- ~CF&~ZF      | 超过(无符号> )        |
| setae  D | setnb  | D <- ~CF          | 超过或相等(无符号>= ) |
| setb  D  | setnae | D <- CF           | 低于(无符号< )        |
| setbe  D | setna  | D <- CF\|ZF       | 低于或相等(无符号<= ) |







### 跳转指令 jump

`jmp *%rax` 是跳转到寄存器 %rax 中的值对应的地址

`jmp *(%rax)`是读取%rax中内存地址，再从内存中读取跳转目标地址值

jump 会根据跳转条件判断，从而跳转到带有标号的目的地：

| 指令         | 同义名 | 跳转条件     | 描述                  |
| ------------ | ------ | ------------ | --------------------- |
| jmp Label    |        | 1            | 直接跳转              |
| jmp *Operand |        | 1            | 简介跳转              |
|              |        |              |                       |
| je Label     | jz     | ZF           | 相等/零               |
| jne Label    | jnz    | ~ZF          | 不相等/非零           |
|              |        |              |                       |
| js Label     |        | SF           | 负数                  |
| jns Label    |        | ~SF          | 非负数                |
|              |        |              |                       |
| jg Label     | jnle   | ~(SF^OF)&~ZF | 大于 (有符号> )       |
| jge Label    | jnl    | ~(SF^OF)     | 大于等于 (有符号>= )  |
| jl Label     | jnge   | SF^OF        | 小于 (有符号< )       |
| jle Label    | jng    | (SF^OF)\|ZF  | 小于等于 (有符号<= )  |
|              |        |              |                       |
| ja Label     | jnbe   | ~CF&~ZF      | 超过(无符号> )        |
| jae Label    | jnb    | ~CF          | 超过或相等(无符号>= ) |
| jb Label     | jnae   | CF           | 低于(无符号< )        |
| jbe Label    | jna    | CF\|ZF       | 低于或相等(无符号<= ) |





### 条件传送指令 CMOV

当传送条件满足时，将源值S 复制到目的 R

| 指令       | 同义名  | 传送条件     | 描述                   |
| ---------- | ------- | ------------ | ---------------------- |
| cmove S,R  | cmovz   | ZF           | 相等/零                |
| cmovne S,R | cmovnz  | ~ZF          | 不相等/非零            |
|            |         |              |                        |
| cmovs S,R  |         | SF           | 负数                   |
| cmovns S,R |         | ~SF          | 非负数                 |
|            |         |              |                        |
| cmovg S,R  | cmovnle | ~(SF^OF)&~ZF | 大于 (有符号> )        |
| cmovge S,R | cmovnl  | ~(SF^OF)     | 大于或等于 (有符号>= ) |
| cmovl S,R  | cmovnge | SF^OF        | 小于 (有符号< )        |
| cmovle S,R | cmovng  | (SF^OF)\|ZF  | 小于或等于 (有符号<= ) |
|            |         |              |                        |
| cmova S,R  | cmovnbe | ~CF&~ZF      | 超过(无符号> )         |
| cmovae S,R | cmovnb  | ~CF          | 超过或相等(无符号>= )  |
| cmovb S,R  | cmovnae | CF           | 低于(无符号< )         |
| cmovbe S,R | cmovna  | CF\|ZF       | 低于或相等(无符号<= )  |





## 过程



### 过程调用 call

| 指令           | 描述               |
| -------------- | ------------------ |
| call  Label    | 过程调用，直接调用 |
| call  *Operand | 过程调用，间接调用 |
| ret            | 从过程调用中返回   |





## 浮点数

浮点数体系结构及相关寄存器

* MMX 最早的媒体(media)指令，支持图形和图像处理
  * SIMD（读作 sim-dee），单指令多数据
  * MM 寄存器，64位
* SSE(Streaming SIMD Extension，流式SIMD扩展)
  * XMM 寄存器，128位
* AVX(Advanced Vector Extension，高级向量扩展)
  * YMM寄存器，256位



### AVX 寄存器

AVX 浮点体系结构允许数据存储在 16 个 YMM 寄存器中，名字为 %ymm0 ~ %ymm15，每个 YMM 寄存器保存32个字节，低16字节可以作为 XMM 寄存器来访问



| 256位  | 128位  | 描述              |
| ------ | ------ | ----------------- |
| %ymm0  | %xmm0  | 1st FP arg.返回值 |
| %ymm1  | %xmm1  | 1nd FP参数        |
| %ymm2  | %xmm2  | 3rd FP参数        |
| %ymm3  | %xmm3  | 4th FP参数        |
| %ymm4  | %xmm4  | 5th FP参数        |
| %ymm5  | %xmm5  | 6th FP参数        |
| %ymm6  | %xmm6  | 7th FP参数        |
| %ymm7  | %xmm7  | 8th FP参数        |
| %ymm8  | %xmm8  | 调用者保存        |
| %ymm9  | %xmm9  | 调用者保存        |
| %ymm10 | %xmm10 | 调用者保存        |
| %ymm11 | %xmm11 | 调用者保存        |
| %ymm12 | %xmm12 | 调用者保存        |
| %ymm13 | %xmm13 | 调用者保存        |
| %ymm14 | %xmm14 | 调用者保存        |
| %ymm15 | %xmm15 | 调用者保存        |





### 浮点数传送和转换

#### vmovss、vmovsd、vmovaps、vmovapd

下面指令用于 xmm 寄存器和内存中传送数据，或者 xmm寄存器之间传送数据

| 指令    | 源       | 目的     | 描述                       |
| ------- | -------- | -------- | -------------------------- |
| vmovss  | M(32bit) | X        | 传送单精度浮点数           |
| vmovss  | X        | M(32bit) | 传送单精度浮点数           |
| vmovsd  | M(64bit) | X        | 传送双精度浮点数           |
| vmovsd  | X        | M(64bit) | 传送双精度浮点数           |
| vmovaps | X        | X        | 传送对齐的封装好的单精度数 |
| vmovapd | X        | X        | 传送对齐的封装好的双精度数 |





#### vcvttss2si、vcvttsd2si、vcvttss2siq、vcvttsd2siq



| 指令        | 源         | 目的     | 描述                                 |
| ----------- | ---------- | -------- | ------------------------------------ |
| vcvttss2si  | X/M(32bit) | R(32bit) | 用截断的方法把单精度数转换成整数     |
| vcvttsd2si  | X/M(64bit) | R(32bit) | 用截断的方法把双精度数转换成整数     |
| vcvttss2siq | X/M(32bit) | R(64bit) | 用截断的方法把单精度数转换成四字整数 |
| vcvttsd2siq | X/M(64bit) | R(64bit) | 用截断的方法把双精度数转换成四字整数 |





#### vcvtsi2ss、vcvtsi2sd、vcvtsi2ssq、vcvtsi2sdq



| 指令       | 源1               | 源2  | 目的 | 描述                     |
| ---------- | ----------------- | ---- | ---- | ------------------------ |
| vcvtsi2ss  | M(32bit)/R(32bit) | X    | X    | 把整数转换成单精度数     |
| vcvtsi2sd  | M(32bit)/R(32bit) | X    | X    | 把整数转换成双精度数     |
| vcvtsi2ssq | M(64bit)/R(64bit) | X    | X    | 把四字整数转换成单精度数 |
| vcvtsi2sdq | M(64bit)/R(64bit) | X    | X    | 把四字整数转换成双精度数 |







### 浮点数运算

#### vaddss、vsubss、vmulss、vdivss、vmaxss、vminss、sqrtss



| 单精度 | 双精度 | 效果         | 描述         |
| ------ | ------ | ------------ | ------------ |
| vaddss | vaddsd | D←S2+S1      | 浮点数加     |
| vsubss | vsubsd | D←S2-S1      | 浮点数减     |
| vmulss | vmulsd | D←S2×S1      | 浮点数乘     |
| vdivss | vdivsd | D←S2/S1      | 浮点数除     |
| vmaxss | vmaxsd | D←max(S2,S1) | 浮点数最大值 |
| vminss | vminsd | D←min(S2,S1) | 浮点数最小值 |
| sqrtss | sqrtsd | D←√￣S2      | 浮点数平方根 |



### 位级操作

#### vxorps、vandps

| 单精度 | 双精度 | 效果    | 描述                   |
| ------ | ------ | ------- | ---------------------- |
| vxorps | vorpd  | D←S2^S1 | 位级异或(EXCLUSIVE-OR) |
| vandps | andpd  | D←S2&S1 | 位级与(AND)            |



### 比较

#### ucomiss、ucomisd



| 指令            | 基于    | 描述         |
| --------------- | ------- | ------------ |
| ucomiss  S1, S2 | S2 - S1 | 比较单精度值 |
| ucomisd  S1, S2 | S2 - S1 | 比较双精度值 |

浮点数比较指令会设置三个条件码：零标志位 ZF、进位标志位 CF、奇偶标志位 PF。

条件码设置条件如下：

| 顺序S2:S1 | CF   | ZF   | PF   |
| --------- | ---- | ---- | ---- |
| 无序的    | 1    | 1    | 1    |
| S2 < S1   | 1    | 0    | 0    |
| S2 = S1   | 0    | 1    | 0    |
| S2 > S1   | 0    | 0    | 0    |

