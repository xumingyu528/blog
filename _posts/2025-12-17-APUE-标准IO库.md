---
title: APUE-标准IO库
permalink: /APUE-标准IO库
category: 操作系统
tag:
  - APUE
  - 操作系统
author: xmy


---



## 引言

标准 IO 库由 ISO C 标准说明。SUS 对 ISO C 标准进行了扩充，定义了一些接口。  

标准 I/O 库处理很多细节，包括缓冲区分配、优化块长度执行 I/O 等。  

Dennis Ritchie 在 1975 年编写，基于 Mike Lesk 编写的可移植 I/O 库的主要修改版本，之后几乎没有修改。





## 流和 FILE 对象

对于标准 I/O 库，它们操作是围绕 **流(stream)** 进行的。当用标准 I/O 库打开或创建一个文件时，使一个流与一个文件相关联。  

对于 ASCII 字符集，一个字符用一个字节表示。对于国际字符集，一个字符可以用多个字节表示。标准 I/O 文件流可用于单字节或多字节(宽)字符集。**流的定向(stream orientation)** 决定了所读、写的字符是单字节还是多字节的。当流被初次创建时，它并没有定向，若使用多字节 I/O 函数，则该流被设置为宽定向的；若使用单字节 I/O 函数，则该流被设置为字节定向的。有两个函数可以改变流的定向：freopen 清除一个流的定向、fwide 设置流的定向。  

```c
#include <stdio.h>
#include <wchar.h>


int fwide(FILE *fp, int mode);
		// 若流是宽定向的返回正值，若流是字节定向的返回负值，未定向的返回 0
```

根据 mode 参数不同值，fwide 函数执行不同工作：

* mode 参数为负，fwide 将试图使指定的流是字节定向的
* mode 参数为正，fwide 将试图使指定的流是宽定向的
* mode 参数为0，将不设置流的定向，返回标识该流定向的值

fwide 并不改变已定向流的方向。并且无出错返回。唯一可靠的方式是调用 fwide 前先清除 errno，从 fwide 返回时检查 errno 的值。  

打开一个流时，标准I/O 函数 fopen 返回一个指向 FILE 对象的指针。FILE 对象通常是一个结构体，包含了标准 I/O 库为管理该流所需要的所有信息：用于实际I/O 的文件描述符、指向用于该流缓冲区的指针、缓冲区的长度、当前在缓冲区中的字符数、出错标志等。



## 标准输入、标准输出、标准错误

对一个进程预定义了3个流，可以自动地被进程使用：标准输入、标准输出、标准错误。  

可以通过预定义的文件指针 stdin、stdout、stderr 加以引用，这3个指针定义在 <stdio.h> 中。





## 缓冲

标准I/O库提供缓冲的目的是减少 read、write 调用的次数，对每个I/O流自动地进行缓冲管理。提供了3种类型：

1. 全缓冲。这种情况下，在填满标准I/O缓冲区才进行实际I/O操作。驻留在磁盘上的文件通常是由标准I/O库实施全缓冲的。一个流上执行第一次I/O操作时，相关标准I/O函数通常调用 malloc 获取所需缓冲区。
   * **冲洗(flush)**：缓冲区可由标准I/O例程自动地 flush，或者调用 fflush 刷新一个流。
2. 行缓冲。在输入、输出中遇到换行符时，标准I/O库进行 I/O 操作。一般终端会使用行缓冲。
   * 如果缓冲区满了，即使没有换行符，也会进行I/O操作
   * 只要通过标准I/O库要求从一个不带缓冲的流或者一个行缓冲地流得到输入数据，那么就会 flush 所有行缓冲输出流。
3. 不带缓冲。标准I/O不对字符进行缓冲存储。

标准错误通常时不带缓冲的，使得错误信息尽快显示出来。  

ISO C 要求如下缓冲特征：

* 当且仅当标准输入和标准输出并不指向交互式设备时，它们才是全缓冲的
* 标准错误绝不会是全缓冲的
* 很多系统默认缓冲类型：
  * 标准错误时不带缓冲
  * 若是指向终端设备的流，则是行缓冲的，否则时全缓冲的

若是不喜欢这些系统默认缓冲类型，可以调用下列函数更改：

```c
#include <stdio.h>


void setbuf(FILE *restrict fp, char *restrict buf);
void setvbuf(FILE *restrict fp, char *restrict buf, int mode, size_t size);
		// 成功则返回0，出错返回非0
```

这些函数一定要在流被打开之后调用，应该在对该流进行任何其他操作前进行调用。  

setbuf 函数打开或关闭缓冲机制。为了带缓冲，参数 buf 必须指向一个长度为 BUFSIZ 的缓冲区(定义在<stdio.h>种)。通常在此之后流时全缓冲的。如果关闭缓冲，则将 buf 设置为 NULL。  

使用 setvbuf 可以精确说明所需缓冲类型，由 mode 参数指定：

* _IOFBF：全缓冲。buf 和 size 指定缓冲区及其长度。如果 buf 为 NULL，则自动地为该流分配适当长度的缓冲区，一般是由常量 BUFSIZ 所指定的值。
* _IOLBF：行缓冲。规则同上。
* _IONBF：不带缓冲。将忽略 buf 和 size 参数

![image-20251217180726340](../upload/2025-12-17-APUE-标准IO库/image-20251217180726340.png)

如果一个函数内分配了一个自动变量类的标准 I/O 缓冲区，则从该函数返回之前，必须关闭该流。  

任何时候都可以强制刷新一个流：

```c
#include <stdio.h>

int fflush(FILE *fp);
		// 成功返回0，出错返回EOF
```

此函数使得该流所有未写的数据都被传送到内核，如果 fp 是 NULL，则所有的输出流都被 flush。





## 打开流

打开标准 I/O 流的函数：

```c
#include <stdio.h>


FILE *fopen(const char *restrict pathname, const char *restrict type);
FILE *freopen(const char *restrict pathname, const char *restrict type, FILE *restrict fp);
FILE *fdopen(int fd, const char *type);
```

1. fopen 打开路径名为 pathname 的文件
2. freopen 在一个指定的流上打开一个指定的文件，如果该流已经打开，则先关闭该流。若流已经定向，则使用 freopen 清除该定向。
3. fdopen 去一个已有的文件描述符(可能通过 open、dup、dup2、fcntl、pipe、socket、socketpair、accept等函数获得此 fd)，并使一个标准 I/O 流与该文件描述符相结合。常用于管道、网络通信通道函数返回的描述符，因为这些特殊类型的文件不能用标准I/O 函数 fopen 打开。

type 参数指定对该 I/O 流的读、写方式，ISO C 规定type 参数可以有 15 种不同的值：

![image-20251218111903624](../upload/2025-12-17-APUE-标准IO库/image-20251218111903624.png)

字符 b 是标准 I/O 系统用于区分文本文件和二进制文件。但 UNIX 内核不对这两种文件进行区分，因此 UNIX 中指定字符b作为 type 的一部分无作用。  

函数 fclose 关闭一个打开的流：

```c
#include <stdio.h>

int fclose(FILE *fp);
		// 成功返回0，出错返回 EOF
```

文件关闭之前，flush 缓冲区的输出数据。缓冲区中的任何输入数据会被丢弃。如果标准I/O库为该流自动分配了一个缓冲区，则释放此缓冲区。  

当一个进程正常终止，则所有带未写缓冲数据的标准I/O流都被 flush，所有打开的标准 I/O 流都被关闭。





## 读和写流

一旦打开流则可以在下列 非格式化I/O 类型中选择一种对其进行读写：

1. 每次一个字符的 I/O。一次读或写一个字符，如果流是带缓冲的，则标准I/O函数处理所有缓冲。
2. 每次一行的 I/O。使用 fgets 和 fputs 函数，每行以一个换行符终止，直接调用 fgets 时，应说明能处理的最大行长。
3. 直接 I/O。fread 、fwrite 函数支持这种I/O。每次I/O操作读或写某种数量的对象，每个对象具有指定的长度。这两个函数通常用于从二进制中每次读或者写一个结构。
   * 直接 I/O(direct I/O)术语来自 ISO C 标准，有时也被称为 二进制I/O、一次一个对象I/O、面向记录的I/O、面向结构的I/O。

### 输入函数

一次读一个字符的函数：

```c
#include <stdio.h>

int getc(FILE *fp);
int fgetc(FILE *fp);
int getchar(void);
		// 成功返回下一个字符，到达文件尾端或者出错返回 EOF
```

getchar 等于 getc(stdin)。getc 可以被实现为宏，而 fgetc 不能，因此：

1. getc 的参数不应当是具有副作用的表达式，因为它可能会被计算多次
2. fgetc 一定是一个函数，因此可以得到其地址，这就允许将 fgetc 的地址作为参数传送给另一个函数
3. 调用 fgetc 所需时间很可能比调用 getc 长，因为通常函数调用所需时间长于宏

这3个函数返回下一个字符时，将其 unsigned char 类型转换为 int 类型。要求整型返回的原因是，这样可以返回所有可能的字符值加上一个已出错或 EOF的指示值。EOF被要求是一个负值，通常定义为-1。因此这3个函数的返回值不能存放在字符变量中，否则无法和常量 EOF 比较。  

出错或者到达文件尾端，这3个函数返回同样的值，因此还需要调用以下函数做区分：

```c
#include <stdio.h>

int ferror(FILE *fp);
int feof(FILE *fp);
		// 为真则返回非0，否则返回0

void clearerr(FILE *fp);
```

大多数实现中为每个流在 FILE 对象中维护了两个标志：

* 出错标志
* 文件结束标志

调用 clearerr 可以清除这两个标志。  

从流中读取数据以后，可以调用 ungetc 将字符再压回流中：

```c
#include <stdio.h>

int ungetc(int c, FILE *fp);
		// 成功返回 c，出错返回 EOF
```

压送回到流中的字符后续又可以从流中读出，但读出的顺序与压送回的顺序相反。例如压送回 a b c，读出 c b a。ISO C 允许实现支持任何次数的回送，但是要求实现提供一次只回送一个字符，不能期望一次回送多个字符。  

* 回送的字符，不一定必须是上次读到的字符。
* 不能回送EOF。
* 当已经到达文件尾端时，仍可以回送一个字符，下次读将返回该字符，再读则返回 EOF。之所以如此，是因为 ungetc 函数调用会清除该流的 EOF。

当正在读一个输入流，并进行某种形式的切词或记号切分操作时，经常会用到回送字符操作。有时需要看一看下一个字符，以决定如何处理当前字符。然后旧需要方便地将刚看到地字符回送，一边下一次调用 getc 时返回该字符。如果标准 I/O 不能提供回送能力，就需要将该字符存放到一个我们自己地变量中，并设置一个标志以便判断在下一次需要一个字符时时调用 getc，还是从我们自己的变量中取用这个字符。  

*用 ungetc 压送回字符时，并没有写到底层文件或设备上，只是将它们写回标准I/O库流的缓冲区*



### 输出函数

与输入函数对应的每个函数都有一个输出函数：

```cc
#include <stdio.h>

int putc(int c, FILE *fp);
int fputc(int c, FILE *fp);
int putchar(int c);
		// 成功则返回字符 c，出错返回EOF
```

putchar(c)等同于 putc(c, stdout)，putc 可以被实现为宏，fputc 不能实现为宏。



## 每次一行I/O

每次读取输入一行的函数：

```c
#include <stdio.h>

char *fgets(char *restrict buf, int n, FILE *restrict fp);
char *gets(char *buf);
		// 成功返回buf，到达文件尾端或出错返回 NULL
```

这两个函数读取的行将送到缓冲区 buf 中。gets 从标准输入读，fgets 从 fp 指定的流读。  

fgets 函数必须指定缓冲的长度 n。此函数一直读到下一个换行符位置，但不超过 n-1 个字符，读入的字符被送入缓冲区。该缓冲区以 null 字节结尾。若该行包括最后一个换行符的字符数超过 n-1 ，则 fgets 只返回一个不完整的行，而缓冲区总是以 null 字节结尾。对 fgets 的下一次调用会继续读该行。  

gets 函数不推荐使用。其在执行时不能 指定缓冲区长度，可能会导致缓冲区溢出。例如 1988 年因特网蠕虫事件。gets 会删除换行符，不将其送入缓冲区。  



输出一行的函数：

```c
#include <stdio.h>

int fputs(const char *restrict str, FILE *restrict fp);
int puts(const char *str);
		//成功返回非负值，出错返回EOF
```

fputs 将一个以 null 字节结尾的字符串写到指定的流，结尾的 null 不写出。通常 null 之前是一个换行符，但不总是如此。  

puts 将一个以 null 字节结尾的字符串写到标准输出，终止符 null 不写出，但会将一个换行符追加到标准输出。  

puts 也尽量避免使用，避免需要记住是否在最后添加了换行符。经常使用 fgets、fputs，会熟悉处理每行结束的换行符。  



## 标准I/O的效率

使用 getc 和 putc 将标准输入复制到标准输出：

```c
#include "apue.h"

int main(){
    int c;

    while(( c = getc(stdin)) != EOF){
        if (putc(c, stdout) == EOF)
            err_sys("output error");
    }

    if(ferror(stdin))
        err_sys("input error");

    exit(0);
}
```

使用 fgets、fputs 的每次读、写一行的版本：

```c
#include "apue.h"

int main(){
    char buf[MAXLINE];

    while( fgets(buf, MAXLINE, stdin) != NULL){
        if (fputs(buf, stdout) == EOF)
            err_sys("output error");
    }

    if(ferror(stdin))
        err_sys("input error");

    exit(0);
}
```



![image-20251218154741642](../upload/2025-12-17-APUE-标准IO库/image-20251218154741642.png)



## 二进制I/O

之前的函数以一次一个字符或一行的方式进行操作数据流。如果进行二进制I/O 操作，那么更好的是一次读或写一个完整的结构。如果使用 getc、putc 处理，通过循环每次处理一个字节读或者写，将会非常复杂和费时。如果使用 fputs、fgets ，那么遇到 null 字节就会停止，而结构中可能含有 null 字节，因此也不能满足处理结构的要求。由此提供了两个函数以执行二进制I/O操作：

```c
#include <stdio.h>

size_t fread(void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);
size_t fwrite(const void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);
		// 返回读写的对象数
```

常见用法：

1. 读或写一个二进制数组。其中 size 为每个数组元素的长度，nobj 为要写的元素个数

   ```c
   // 将一个浮点数组的第 2~5 个元素写到一个文件上
   float data[10];
   
   if(fwrite(&data[2], sizeof(float), 4, fp) != 4)
       err_sys("fwrite error");
   ```

2. 读或写一个结构体。其中 size 为结构体的长度，nobj 为要写的对象个数

   ```c
   struct {
       short count;
       long total;
       char name[NAMESIZE];
   } item;
   
   if(fwrite(&item, sizeof(item), 1, fp) != 1)
       err_sys("fwrite error");
   ```

将上面示例结合起来可以读或者写一个结构体数组，size 是结构体的 sizeof，nobj 是数组中元素的个数。  

fread、fwrite 返回读写的对象数。对于读，如果出错或者EOF，此数字可以小于 nobj。这种情况应该调用 ferror、feof 来判断具体那种情况。对于写，返回值小于要求的 nobj 则出错。  

二进制 I/O 只能用于读在同一系统上已写的数据。但如今很多异构系统，它们通过网络相互连接，这种环境下，这两个函数不能正常工作，原因是：

1. 在一个结构体中，同一成员的偏移量可能随编译程序和系统的不同而不同(可能对齐要求不同)。
2. 用来存储多字节整数和浮点数的二进制格式在不同的系统结构间也可能不同。



在不同系统之间交换二进制数据的实际解决方法是使用互认的规范格式。





## 定位流

有3中方法定位标准 I/O 流。

1. ftell、fseek 函数。它们假定文件的位置可以存放在一个长整型中。
2. ftello、fseeko 函数。SUS 引入这两个函数，使文件偏移量可以不必一定使用长整型。它们使用 off_t 数据类型代替了长整型
3. fgetpos、fsetpos 函数。这两个函数是由 ISO C 引入的。使用一个抽象数据类型 fpos_t 记录文件的位置。这种数据类型可以根据需要定义一个足够大的数，用以记录文件位置。

需要移植到非 UNIX 的应用应该使用 fgetpos 和 fsetpos。

```c
#include <stdio.h>

long ftell(FILE *fp);
		// 成功返回当前文件位置指示，出错返回-1L

int fseek(FILE *fp, long offset, int whence);
		// 成功返回0，出错返回-1

void rewind(FILE *fp);
```

对于一个二进制文件，其文件位置指示器是从文件起始位置开始度量，并以字节为度量单位的。ftell 用于二进制文件时，其返回值就是这种字节位置。为了用 fseek 定位一个二进制文件，必须指定一个字节 offset，以解释这种偏移量的方式。whence 的值与 lseek 函数中的相同：SEEK_SET 标识从文件的起始位置开始，SEEK_CUR 标识从当前文件位置开始，SEEK_END 表示从文件尾部开始。  

对于文本文件，它们的文件当前位置可能不以简单的字节偏移量来度量。因为非 UNIX 系统中，可能以不同格式存放文本文件。为了定位一个文本文件，whence 一定要是 SEEK_SET，offset 只能为 0(后退到文件的起始位置)，或者是对该文件的 ftell 所返回的值。使用 rewind 函数也可以将一个流设置到文件的起始位置。  

除了偏移量的类型是 off_t 而非 long 以外， ftello 函数和 ftell 相同，fseeko 和 fseek 相同：

```c
#include <stdio.h>

off_t ftello(FILE *fp);
		// 成功返回当前文件位置，出错返回(off_t)-1

int fseeko(FILE *fp, off_t offset, int whence);
		// 成功返回0，出错返回-1
```

fgetpos 和 fsetpos 是 ISO C 标准引入的：

```c
#include <stdio.h>

int fgetpos(FILE *restrict fp, fpos_t *restrict pos);
int fsetpos(FILE *fp, const fpos_t *pos);
		// 成功返回0，出错返回非0

```

fgetpos 将文件位置指示器的当前值存入由 pos 指向的对象中，在以后调用 fsetpos 时，可以用此值将流重新定位至该位置。





## 格式化I/O

### 格式化输出





### 格式化输入







## 实现细节







## 临时文件







## 内存流







## 标准I/O的替代软件




```

```

```

```