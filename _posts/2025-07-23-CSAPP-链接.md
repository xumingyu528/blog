

## 编译器驱动程序

大多数编译系统提供 编译器驱动程序（compiler driver），在用户需要时调用语言预处理器、编译器、汇编器和链接器  

编译过程：

* 驱动程序先运行C预处理器（cpp），将 C 的源代码程序翻译成 ASCII 码的中间文件 `.i`结尾
  * 例如 `main.c` 翻译成 `main.i`
* 运行C编译器（cc1），将中间文件翻译成汇编语言文件 `.s`结尾
  * 例如 `main.i` 翻译成 `main.s`
* 运行汇编器（as），将汇编文件翻译成一个 `可重定位目标文件（relocatable object file）`
  * 例如 `main.s` 翻译成 `main.o`
* 程序由多个文件组成时，会重复上述过程，生成多个目标文件
* 最后运行链接器程序（ld），将多个目标文件和必要的系统文件组合起来，创建一个可`执行目标文件（executable object file）`
  * 例如 `main.o` 和 `sum.o` 组合链接成 `prog`



* 程序运行时，调用操作系统中的`加载器（loader）`函数，将可执行文件的代码和数据复制到内存，然后将控制转移到这个程序的开头







## 静态链接（static linker）

为了构造可执行文件，链接器必须完成两个任务：

* 符号解析（symbol resolution）
  * 目标文件定义和引用符号，每个符号对应一个函数、一个全局变量或一个静态变量（C语言中任何以 static 属性声明的变量）
  * 符号解析的目的是将每个符号引用正好和一个符号定义关联起来
* 重定位（relocation）
  * 编译器和汇编器生成从地址0开始的代码和数据节（section)
  * 链接器通过把每个符号定义与一个内存未知关联起来，从而重定位这些节(section)，然后修改所有对这些符号的引用，使得它们指向这个内存位置
  * 链接器使用汇编器产生的重定位条目（relocation entry）的详细指令，不加甄别地执行这样的重定位





## 目标文件

目标文件有三种形式

* 可重定位目标文件
* 可执行目标文件
* 共享目标文件



一个目标模块（object module）就是一个字节序列，而一个目标文件就是一个以文件形式存放在磁盘中的目标模块，有时候互换的使用这些术语。  

各个系统的目标文件都不相同：

* windows ：PE（Portable Executable）
* Mac OS-X：Mach-O
* Linux、UNIX：ELF（Excutable and Linkable Format）



## 可重定位目标文件



| 典型的 ELF 可重定位目标文件 |
| --------------------------- |
| ELF头                       |
| .text                       |
| .rodata                     |
| .data                       |
| .bss                        |
| .symtab                     |
| .rel.text                   |
| .rel.data                   |
| .debug                      |
| .line                       |
| .strtab                     |
| 节头部表                    |

夹在 ELF 头和节头部表之间的都是节(section)，一个典型的 ELF 可重定位目标文件包含下面几个节：

* .text：已编译程序的机器代码
* .rodata：只读数据，例如 printf 语句的格式串
* .data：已初始化的全局和静态 C 变量。
  * 注：局部 C 变量在运行时被保存在栈中，不出现在.data及.bss节中
* .bss：未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量。
  * bss 是`块存储开始（Block Storage Start）`指令的首字母缩写，起始于 IBM 704 汇编语言
* .symtab：一个符号表，它存放 在程序中定义和引用的函数和全局变量的信息。
* .rel.text：一个 .text 节中位置的列表
* .rel.data：被模块引用或定义的所有全局变量的重定位信息
* .debug：一个调试符号表。只有以 -g 选项调用编译器驱动程序时，才会得到这张表
* .line：原始 C 源程序中的行号和 .text 节中机器指令之间的映射。需要 -g 选项才会得到这张表
* .strtab：一个字符串表，内容包括 .symtab 和 .debug 节中的符号表，以及节头部中的节名字。以 null 结尾的字符串的序列。



## 符号和符号表

在链接器上下文中，有三种不同的符号：

* 全局符号：对应于非静态的 C 函数和全局变量
* 外部符号：被本模块引用的全局符号，对应于在其他模块中定义的非静态 C 函数和全局变量
* 局部符号：对应于带 static 属性的 C 函数和全局变量。不能被其他模块引用



符号表是由汇编器构造的，使用编译器输出到汇编语言 .s 文件中的符号。.symtab 节包含 ELF 符号表。  

```C
typedef struct {
    int name;
    char type:4,
    	 binding:4;
    char reserved;
    short section;
    long value;
    long size;
} Elf64_Symbol;
```



这张符号表包含一个条目的数组：  

* name 是字符串表中的字节偏移，指向符号的以 null 结尾的字符串名字。
* type 通常是数据或者函数。
* binding 字段表示符号是本地的还是全局的。
* reserved 是保留字段
* section 字段是到节头部表的索引
  * 有三个特殊的伪节(pseudosection)
    * ABS：不该被重定位的符号
    * UNDEF：未定义的符号，在本模块中引用，但是却在其他地方定义的符号
    * COMMON：表示还未被分配位置的未初始化的数据条目
    * 可重定位目标文件中才有这些节，可执行目标文件中是没有的
* value 是符号的地址，对于可重定位模块，value 是距定义目标的节起始位置的偏移。
* size 是目标的大小（单位是字节）



注：COMMON 和 .bss 有很小的区别：

* COMMON 未初始化的全局变量
* .bss 未初始化的静态变量，以及初始化为 0 的全局或静态变量



`GUN READELF` 是一个查看目标文件内容的很方便的工具。



## 符号解析

在编译时，编译器向汇编器输出每个全局符号，或者是强（strong）或者是弱（weak），汇编器把这个信息隐含地编码在可重定位目标文件的符号表里。  

函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。  

Linux 解析符号规则：

* 不允许有多个同名的强符号
* 如果有一个强符号和多个弱符号同名，那么选择强符号
* 如果有多个弱符号同名，那么从这些弱符号中任意选择一个



### 与静态库链接

相关函数可以被编译为独立的目标模块，然后封装成一个单独的静态库文件。应用程序可以通过在命令行上指定单独的文件名字来使用这些在库中定义的函数。  

例如，在 C 标准库和数学库中函数的程序可以用如下命令行来编译和链接：

```bash
> gcc main.c /usr/lib/libm.a /usr/lib/libc.a
```



示例：

```c
// addvec.c
int addcnt = 0;

void addvec(int *x, int *y, int *z, int n)
{
	int i;

	addcnt++;

	for (i=0; i<n; i++)
		z[i] = x[i] + y[i];
}


// multvec.c
int multcnt = 0;

void multvec(int *x, int *y, int *z, int n)
{
	int i;

	multcnt++;

	for (i=0; i<n; i++)
		z[i] = x[i] + y[i];
}

// vector.h
void addvec(int *x, int *y, int *z, int n);
void multvec(int *x, int *y, int *z, int n);




// main.c
#include <stdio.h>
#include "vector.h"

int x[2] = {1, 2};
int y[2] = {3, 4};
int z[2];


int main()
{
	addvec(x, y, z, 2);
	printf("z = [%d %d]\n", z[0], z[1]);
	return 0;
}

```

```bash
// 生成 addvec、multvec 的可重定位目标文件
gcc -c addvec.c multvec.c

// 创建静态库
ar rcs libvector.a addvec.o multvec.o

// 生成 main 可重定位目标文件
gcc -c main.c

// 编译和链接输入文件 main.o 和 libvector.a，生成可执行文件 prog
// -static 参数告诉编译器驱动程序，链接器应该构建一个完全链接的可执行目标文件，可以加载到内存并运行，这样在加载时无需更进一步的链接。
gcc -static -o prog main.o ./libvector.a
// 下面命令等同与上面，-L. 参数告诉链接器在当前目录下查找 libvector.a 
gcc -static -o prog main.o -L. -lvector


// 执行 prog
./prog
z = [4 6]
```

上面示例中用到 libc.a 的 printf.o 和其他 printf.o 调用的模块会被链接器（ld）复制到可执行文件中。程序没有引用 multvec.o 中定义的符号，因此不会复制此模块到可执行文件。  



### 链接器使用静态库解析引用

Linux 链接器在符号解析阶段，从左到右按照在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件。此次扫描中，链接器维护了：

* 一个可重定位目标文件的集合 E（这个集合中的文件会被合并起来形成可执行文件）

* 一个未解析的符号集合 U

* 一个前面输入文件中已定义的符号集合 D

* 初始时这几个集合均为空

* 对于命令行上的每个输入文件 f，链接器会判断 f 是一个目标文件还是一个存档文件

* 如果 f 是目标文件，链接器会把 f 添加到 E ，修改 U 和 D 来反映 f 中的符号定义和引用，并继续下一个文件

* 如果 f 是存档文件，链接器会尝试匹配 U 中未解析的符号和存档文件成员定义的符号。如果某个存档文件成员 m，定义了一个符号来解析 U 中的一个引用，那么就将 m 加到 E 中，并修改 U 和 D 来反映 m 中的符号定义和引用。对所有存档文件都进行这个过程

* 如果链接器完成对命令行上输入文件的扫描后，U 是非空的，那么链接器就会输出一个错误并终止

  * 例如使用上面的示例，改变参数顺序，编译器将会报错：

  * ```bash
    gcc -static ./libvector.a mian.c
    /usr/bin/ld: /tmp/ccwQgMbP.o: in function `main':
    main.c:(.text+0x2c): undefined reference to `addvec'
    collect2: error: ld returned 1 exit status
    ```

  * 这是由于处理 libvector.a 时， U 是空的，所以没有 libvector.a 的成员目标文件会添加到 E 中，因此对于 addvec 的引用不会被解析，链接器报错并终止

* 因此一般将库放在命令行的结尾

* 如果库之间有相互引用，必须按照引用排序，被引用的符号 s 所在的库，需要在引用文件之后

  * 例如 foo.c 调用了 libx.a 、libz.a 中的函数，这两个库又调用了 liby.a 中的函数，那么命令行中 libx.a 、libz.a 必须在 liby.a 之前

  * ````
    gcc foo.c libx.a libz.a liby.a
    ````

* 为了满足依赖，可以在命令行上重复库，或者将两个库合并成单独的库

  * ```bash
    gcc foo.c libx.a liby.a libx.a
    ```





## 重定位

重定位将合并输入模块，并未每个符号分配运行时地址，由两步组成：

* 重定位节和符号定义：链接器将所有相同类型的节合并为同一类型的新的聚合节，例如所有输入模块的 .data 节被合并成一个节
* 重定位节中的符号引用：链接器修改代码节和数据节中对每个符号的引用，使得他们指向正确的运行时地址。此步骤依赖于可重定位目标模块中称为 `重定位条目(relocation entry)` 的数据结构



### 重定位条目

代码的重定位条目放在 .rel.text 中，已初始化数据的重定位条目放在 .rel.data 中。

ELF重定位条目格式：

```c
typedef struct {
    long offset;	// 需要被修改的引用的节偏移
    long type:32,	// 告知链接器如何修改新的引用
    	 symbol:32;	// 标识被修改引用应该指向的符号
    long addend;	// 有符号常数，一些类型的重定位要使用它对被修改引用的值做偏移调整
} Elf64_Rela;
```

ELF 定义了32种不同的重定位类型，这里只关心两种最基本的类型：

* R_X86_64_PC32：重定位一个使用32位PC相对地址的引用，PC值通常是下一条指令在内存中的地址
* R_X86_64_32：重定位一个使用32位绝对地址的引用





### 重定位符号引用

伪代码：

```c
foreach section s {
    foreach relocatrion entry r {
        refptr = s + r.offset;   // 需要被重定位的4字节引用的节数组 s 指针
        
        /* PC 相对引用 */
        if (r.type == R_X86_64_PC32) {
            refaddr = ADDR(s) + r.offset;
            *refptr = (unsigned) (ADDR(r.symbol) + r.addend - refaddr);
        }
        
        
        /* 绝对地址引用 */
        if (r.type == R_X86_64_32)
            *refptr = (unsigned) (ADDR(r.symbol) + r.addend);
        
        
    }
}
```



### 示例

```assembly
0000000000000000 <main>:
	0: 	48 83 ec 08				sub		$0x8,%rsp
	4: 	be 02 00 00 00			mov		$0x2,%esi
	9: 	bf 00 00 00 00			mov		$0x0,%edi		%edi = &array
							a: R_X86_64_32 array		Relocation entry
	
	e: 	e8 00 00 00 00			callq 	13 <main+0x13>	sum()
							f: R_X86_64_PC32 sum-0x4	Relocation entry
	13: 48 83 c4 08				add 	$0x8,%rsp
	17:	c3						retq
```





#### 重定位PC相对引用

在书中示例 sum 方法地址位于节偏移 0xe 的地方，包括1字节的操作码 0xe8。

重定位条目 r 由4个字段组成：

```
r.offset 	= 0xf
r.symbol 	= sum
r.type 		= R_X86_64_PC32
r.addend 	= -4
```

假设链接器已确定：

ADDR(s) = ADDR(.text) = 0x4004d0

和

ADDR(r.symbol) = ADDR(sum) = 0x4004e8



使用上面7.2章节的算法，链接器首先计算出引用的运行时地址：

```
refadd 	= ADDR(s) + r.offset
		= 0x4004d0 + 0xf
		= 0x4004df
```

然后更新该引用，是的它在运行时指向 sum 程序：

```
*refptr	= (unsigned) (ADDR(r.symbol) + r.addend - refaddr)
		= (unsigned) (0x4004e8 + (-4) - 0x4004df)
		= (unsigned) (0x5)
```

可执行目标文件中，call 指令有如下重定位形式：

```
4004de: e8 05 00 00 00 		callq 4004e8 <sum> sum()
```

在运行时，call 指令将存放在地址 0x4004de 处，当CPU执行call指令时，PC的值为 0x4004e3，即紧随在call指令之后的指令的地址。为了执行这条指令，CPU执行以下步骤：

* 将 PC 压入栈中
* PC <- PC + 0x5 = 0x4004e3 + 0x5 = 0x4004e8

因此要执行的下一条指令就是 sum 例程的第一条指令。





#### 重定位绝对引用



占位符条目 r 由4个字段组成：

```
r.offset 	= 0xa
r.symbol 	= array
r.type 		= R_X86_64_32
r.addend 	= 0
```

假设链接器已经确定：

ADDR(r.symbol) = ADDR(array) = 0x601018

链接器使用上面章节的算法修改引用：

```
*refptr	= (unsigned) (ADDR(r.symbol) + r.addend)
		= (unsigned) (0x601018 + 0)
		= (unsigned) (0x601018)
```

在可执行目标文件中，该引用有如下重定位形式：

```
4004d9:		br 18 10 60 00 			mov 		$0x601018,%edi  %edi = array
```





## 可执行目标文件





| 典型的 ELF 可执行目标文件 |
| ------------------------- |
| ELF头                     |
| 段头部表                  |
| .init                     |
| .text                     |
| .rodata                   |
| .data                     |
| .bss                      |
| .symtab                   |
| .debug                    |
| .line                     |
| .strtab                   |
| 节头部表                  |

* .init 节定义了一个小函数，叫做 `_init` ，程序的初始化代码会调用它
* .text、.rodata、.data 节和可重定位目标文件中的节是相似的
* 可执行文件时完全链接的（已被重定位），不再需要 .rel 节



可执行文件的连续的片（chunk）被映射到连续的内存段。程序头部表（program header table）描述了这种映射关系。  

程序头部表中包含：

* off：目标文件中的偏移
* vaddr/paddr：内存地址
* align：对齐要求
* filesz：目标文件中的段大小
* memsz：内存中的段大小
* flags：运行时访问权限





## 加载可执行目标文件



```bash
linux> ./prog
```

上面示例是在linux上运行 prog 程序，prog 不是shell内置命令，所以shell会认为 prog 是一个可执行目标文件，通过调用某个驻留在存储器中称为加载器（loader）的操作系统代码来运行它。  

* 任何 Linux 程序都可以已通过调用 execve 函数来调用加载器。  

* 加载器将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口来运行该程序。  

* 这个过程叫做__加载__

每个 Linux 程序都有一个运行时内存映像

* 代码段总是从 0x400000 处开始，后面是数据段
* 运行时堆在数据段之后，通过调用 malloc 库往上增长
* 堆后面的区域是为共享模块保留的
* 用户栈总是从最大的合法用户地址（2的48次幂-1）开始，向较小的内存地址增长
* 内核（kernel）中的代码和数据驻留在内存 （2的48次幂-1）往上









## 动态链接共享库

静态库解决了如何让大量相关函数对应用程序可用的问题，但也有一些明显的缺点：

* 需要定期维护和更新，程序员想要用到更新后的功能，需要显式地将程序与更新了的库重新链接。  
* 几乎每个C程序都使用标准 I/O 函数，例如 printf 和 scanf。在运行时这些函数代码会被复制到每个运行进程的文本段内，如果运行着几十上百个进程的操作系统上，将对内存造成极大浪费。



__共享库(shared library)__是为了解决上述问题设计出来的，共享库是一个目标模块，在运行时或加载时，可以加载到任意的内存地址，冰河一个在内存中的程序链接起来。

* 这个过程称为动态链接（dynamic linking），是由一个叫做动态链接器（dynamic linker）的程序来执行的。
* 共享库也称为共享目标（shared object），在 Linux 系统中通常用 .so 后缀表示，微软 Windows 中称为 DDL（动态链接库）



共享库是以两种不同的方式来“共享”的

* 任何给定的文件系统中，对于一个库只有一个 .so 文件，所有引用该库的可执行目标文件共享这个 .so 文件中的代码和数据
* 在内存中，一个共享库的 .text 节的一个副本可以被不同的正在运行的进程共享



链接了动态共享库的可执行程序中包含一个 .interp 节，这一节包含动态链接器的路径名，加载器会加载和运行这个动态链接器，然后动态链接器执行重定位：

* 重定位共享库 .so 文件的文本和数据到某个内存段
* 重定位可执行程序中所有对共享库中定义的符号的引用



示例

```bash
## -fpic 参数表示生成位置无关代码， -shared 表示链接器创建有共享的目标文件
linux> gcc -shared -fpic -o libvector.so addvec.c multvec.c

linux> gcc -o prog21 main2.c ./libvector.so
```





## 从应用程序中加载和链接共享库

上述描述了应用程序在被加载后执行前，动态链接器加载和链接共享库。但应用程序还有可能在运行时要求动态链接器加载和链接某个共享库。



Linux 系统为动态链接器提供了一个简单的接口，允许应用程序在运行时加载和链接共享库。

```C
#include <dlfcn.h>
void *dlopen(const char *filename, int flag);
```

* dlopen 函数加载和链接共享库 filename。用已用带 RTLD_GLOBAL 选项打开了的库解析 filename 中的外部符号。
* 如果当前可执行文件是带 -rdynamic 选项编译的，那么对符号解析而言，他的全局符号也是可用的。
* flag 参数必须包括 RTLD_NOW 或者 RTLD_LAZY标志
  * RTLD_NOW 标志表示立即解析对外部符号的引用
  * RTLD_LAZY 标志表示推迟符号解析，直到执行来自该库中的代码时再解析
  * 这两个值都可以和 RTLD_GLOBAL 标志取或



```C
#include <dlfcn.h>
void *dlsym(void *handle, char *symbol);
```



* dlsym 函数的输入是一个指向前面打开的共享库的句柄和一个 symbol 名，如果该符号存在，就返回符号地址，否则返回 NULL





```C
#include <dlfcn.h>
void dlclose (void *handle);
```

* 如果共享库没有再被使用，dlclose 函数卸载共享库





```C
#include <dlfcn.h>
const char *dlerror(void);
```

* dlerror 函数返回一个字符串，描述调用 dlopen、dlsym、dlclose 函数时发生的最近的错误，如果没有错误返回 NULL



示例代码：

```C
#include <stdio.h>
#include <stdlib.h>
#include <dlfcn.h>

int x[2] = {1, 2};
int y[2] = {3, 4};
int z[2];

int main()
{
    void *handle;
    void (*addvec)(int *, int *, int *, int);
    char *error;

    handle= dlopen("./libvector.so", RTLD_LAZY);
    if (!handle)
    {
        fprintf(stderr, "%s\n", dlerror());
        exit(1);
    }

    addvec = dlsym(handle, "addvec");
    if ((error = dlerror()) != NULL)
    {
        fprintf(stderr, "%s\n", error);
        exit(1);
    }

    addvec(x, y, z, 2);
    printf("z = {%d, %d}\n", z[0], z[1]);

    if (dlclose(handle) != 0)
    {
        fprintf(stderr, "%s\n", dlerror());
        exit(1);
    }
    return 0;
    
}
```









## 位置无关代码

可以加载而无需重定位的代码称为__位置无关代码(Position-Independent Code, PIC)__，用户对 GCC 使用 -fpic 选项指示 GNU 编译系统生成 PIC 代码。共享库的编译必须总是使用该选项。  

在x86_64 系统中，对同一个目标模块中符号的引用是不需要特殊处理使之成为 PIC。可以用 PC 相对寻址来编译这些引用，构造目标文件时由静态链接器重定位。对共享模块定义的外部过程和全局变量的引用需要一些特殊技巧。

### PIC 数据引用

* 无论我们在内存中何处加载一个目标模块，数据段和代码段的距离总是保持不变，代码段中任何指令和数据段中任何变量之间的距离都是一个运行时常量
* 编译器利用这个事实，在数据段开始的地方创建一个表，叫做__全局偏移量表(Global Offset Table, GOT)__ 
* 每个被这个目标模块应用的全局数据目标（过程或全局变量）都有一个8字节条目
* 编译器为GOT中每个条目生成一个重定位记录
* 在加载时，动态链接器会重定位GOT中的每个条目，使得它包含目标的正确的绝对地址



### PIC 函数调用

GNU 编译系统使用__延迟绑定(lazy binding)__ ，将函数调用过程地址的绑定推迟到第一次调用该过程时。延迟绑定通过两个数据结构之间交互实现的：

* GOT 
* 过程链接表(Procedure Linkage Table, PLT)

如果一个目标模块调用定义在共享库中的任何函数，那么它机油自己的 GOT 和 PLT，GOT是数据段的一部分，PLT 是代码段的一部分。

#### 过程链接表（PLT）

* PLT 是一个数组，其中每个条目是 16 字节代码
* PLT[0]是一个特殊条目，自动跳转到动态链接器中
* PLT[1]调用系统启动函数(__libc_start_main)，初始化执行环境，调用main函数并处理其返回值
* 从PLT[2]开始的条目调用用户代码调用的函数，例如 addvec、printf 等



#### 全局偏移量表（GOT） 

* GOT 也是一个数组，每个条目8字节地址
* 在和 PLT 联合使用时，GOT[0]、GOT[1]包含动态链接器在解析函数地址时会使用的信息
* GOT[2]是动态链接器在 ld-linux.so 模块中的入口点
* 其余每个条目对应于一个被调用的函数，其地址在运行时被解析
* 每个条目都有一个对应的 PLT 条目
* 初始时，每个GOT条目指向对应 PLT 条目的第二条指令









## 库打桩机制

Linux 链接器支持一个很强的的技术 __桩打库(library interpositioning)__，它允许你接货对共享库函数的调用，取而代之执行自己的代码。  

使用桩打库机制，你可以追踪对某个特殊库函数的调用次数，验证和追踪它的输入和输出值，甚至替换成一个完全不同的实现。

  

它的基本思想是：

* 给定一个需要打桩的__目标函数__，创建一个__包装函数__，它的原型于目标函数完全一样
* 使用某种特殊的打桩机制，你就可以欺骗系统调用包装函数而不是目标函数了。
* 包装函数通常会执行自己的逻辑，然后对奥用目标函数，再讲目标函数返回值传递给调用者
* 打桩可以发生在编译时、链接时、程序被夹在和执行的运行时



示例程序：

int.c 调用malloc和free函数，分配32字节的块，返回该块的指针，示例程序追踪程序运行时对 malloc 和 free函数的调用

int.c：

```C
#include <stdio.h>
#include <malloc.h>

int main()
{
    int *p = malloc(32);
    free(p);
    return(0);
}
```

malloc.h：

```C
#define malloc(size) mymalloc(size)
#define free(ptr) myfree(ptr)

void *mymalloc(size_t size);
void myfree(void *ptr);
```

malloc.c：

```C
#ifdef COMPILETIME
#include <stdio.h>
#include <malloc.h>

void *mymalloc(size_t size) {
    void *ptr = malloc(size);
    printf("malloc(%d) = %p\n", (int)size, ptr);
    return ptr;
}


void myfree(void *ptr) {
    free(ptr);
    printf("free(%p)\n", ptr);
}
#endif
```









### 编译时打桩

编译和链接程序：

```bash
gcc -DCOMPILETIME -c mymalloc.c
gcc -I. -o intc int.c mymalloc.o
```

运行程序：

```bash
./intc
malloc(32) = 0x556e8133a2a0
free(0x556e8133a2a0)
```



### 链接时打桩

Linux 静态链接器支持 `--wrap f` 标志进行链接时打桩。



把源文件编译成可重定位目标文件：

```bash
gcc -DLINKTIME -c mymalloc.c
gcc -c int.c
```

链接成可执行文件：

```bash
gcc -Wl, --wrap,malloc -Wl, --wrap,free -o intl int.o mymalloc.o
```

-Wl 选项标志把 option 传递给链接器



### 运行时打桩

构建包含包装函数的共享库的方法：

```bash
gcc -DRUNTIME -shared -fpic -o mymalloc.so mymalloc.c -ldl
```

编译主程序：

```bash
gcc -o intr int.c
```

运行程序：

```bash
LD_PRELOCA="./mymalloc.so" ./intr
```



LD_PRELOAD 可以对任何可执行程序的库函数调用打桩！







## 工具

GNU binutils 包有很多处理目标文件的工具

* AR：创建静态库，插入、删除、列出和提取成员
* STRINGS：列出一个目标文件中所有可打印的字符串
* STRIP：从目标文件中删除符号表信息
* NM：列出一个目标文件的符号表中定义的符号
* SIZE：列出目标文件中节的名字和大小
* READELF：显示一个目标文件的完整结构，包括ELF头中编码的所有信息。包含SIZE和NM的功能
* OBJDUMP：所有二进制工具之母。能够显示一个目标文件中所有的信息。它最大的作用是反汇编 .text 节中的二进制指令
* LDD：列出一个可执行文件在运行时所需要的共享库